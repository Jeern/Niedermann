{"_id":"624766d0-9f40-11e8-9eea-d14ec2a4b667","name":"Jesper","email":"ad62b4d7c02afdc2eb85410979c71283","body":"Hi Patrick,\n\nThank you for comment. Nice to get feedback :O)\n\nFirst look at page 98 of Juval Lowys book \"Programming .NET components.\" I guess I am a fan of his. :O) The Dispose pattern presented by me is just an improved version of his Dispose Pattern (and nicer looking :O) ). He makes what he almost calls a \"bulletproof\" Dipose pattern. This of course also means that not all parts of it is necessary all the time. But it certainly helps.\n\nI will answer each of your comments here:\n\n\"virtual (polymorphistic) mehods for releasing managed and unmanaged code should be called Dispose(bool disposed)\"\n\n- I am  not sure were you get this \"rule\" from ? Are you just referering to the naming of FreeManagedRessources and FreeUnmanagedRessources ? I guess DisposeManagedResources could be a better name.\n\n\"keep releasing methods for unmanaged and managed code(like \"FreeManagedResources\" and \"FreeUnmanagedResources\") always private for the class itself, it is the responsibility of the class and not for derived classes\"\n\n- Hmm... This sort of implies that you never inherit a Disposable class. If you call Dispose on the derived class you would have to override the Dispose method itself repeating the whole pattern.\n\n\"a finalizer is expensive to introduce. You only need them when the class holds unmanaged resources to be sure that unmanaged resources are always cleaned up by the GC.\"\n\n- A finalizer should ONLY be used for releasing unmanaged resources (as you say yourself), and that is exactly what I do. Look at the code again :O) Not only that. A finalizer should ALWAYS be used for releasing unmanaged resources. because otherwise you have no guarantee they will be released. Of course you have a point that if there are no unmanaged resources there are no reason to provide a finalizer. But then again, you will not be able to convince me that a finalizer that does nothing is expensive :O) And furthermore this pattern is just a best practice attempt, and consequently I have to provide the finalizer.\n\n\"[MethodImpl(MethodImplOptions.Synchronized)] is not needed by default.\"\n\n- I guess you are right. But again this is a best practice attempt. This attribute means exactly the same as lock(this), but is better because it locks the entire method which lock(this) only does if you do it right ;O). Just consider two different threads trying to Dispose the same object, without the lock they could both be trying to free the same unmanaged ressources which could potentially be dangerous. BTW: The lock statement I also got from Juval's book. I just brought it into the present with the MethodImpl attribute, which Juval often prefers too.\n\n\"use camelCasing instead of m_ for class fields (this is Microsoft's default), but that's just code style.\"\n\n- Well it is just coding style, but I strongly disagree :O) I code by IDesigns coding standard which uses m_ and which is written by - guess who - Juval Lowy :O) And why is it wrong to use camelCasing ? Because it forces you to use the this keyword, which should only be used during development IMHO (and of course for extension methods and constructors. Microsoft is split on this matter. Their generated code often looks like what you describe, and at other times uses an underscore as prefix. The first one is wrong (IMHO), the second is a matter of coding style.\n\nAgain thank you for the feedback. I didn't understand your first point, but the rest made me think, even though I disagree. I haven't been changing this  pattern for a few years now and I think I will keep on using it. At least it has not given me any trouble. :O)","date":"2009-06-23T22:32:53.471457+02:00"}

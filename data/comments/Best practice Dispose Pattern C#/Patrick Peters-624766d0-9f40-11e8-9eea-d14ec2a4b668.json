{"_id":"624766d0-9f40-11e8-9eea-d14ec2a4b668","name":"Patrick Peters","email":"5EE0A381449DC09A00A0F9F3E6105F97","body":"Hi Jesper,\n\nThe template I am using is coming from Microsoft's MSDN site and is also used by Bill Wagners \"Effective C#: 50 Specific Ways to Improve Your C#\". IDesign's coding standards are very useful and helpful but are not always in line with Microsoft's guidelines. This also the fault of Microsof itself where there some gaps in the guidelines. The one and only coding guidelines reference that is used by all MS teams is the book \"Framework Design Guidelines\" and the Dispose template I am referring to is coming from that book also. MSDN is also referering to that book but can only state slices of the text from it due to legal/copyright stuff.\n\nHere are my replies again, read the text after ->>>>>\n\n- I am not sure were you get this \"rule\" from ? Are you just referering to the naming of FreeManagedRessources and FreeUnmanagedRessources ? I guess DisposeManagedResources could be a better name.  ->>>> this rule is coming from the Dispose template in MSDN and in Framework Design Guidelines. All MS teams are implementing this way, and also check the .NET library itself how disposable components are implemented (use reflector for it for example). When you design a disposable component (class) that is not sealed, you should declare a virtual method named \"Dispose(bool disposing)\". When you derive from that component, you can override it, dispose your managed and unmanaged code and then call base.Dispose(disposing). You can reuse your methods called FreeManagedRessources and FreeUnmanagedRessources in this overriden dispose method of course ;-)\n\nThis is the Dispose template I am using (and is coming from MS/Framework Design Guidelines)\n\n\n    public class MyHelper : IDisposable\n    {\n        private bool disposed;\n        \n        public MyHelper()\n        {\n        }\n\n        ~MyHelper()\n        {\n            Dispose(false);\n        }\n\n        #region IDisposable Members\n\n        public void Dispose()\n        {\n            Dispose(true);\n            \n            GC.SuppressFinalize(this);\n        }\n\n        #endregion\n\n        protected virtual void Dispose(bool isDisposing)\n        {\n            if (!this.disposed)\n            {\n                if (isDisposing)\n                {\n                    //cleanup managed resources here, you may also chain it to a private method in this class\n                }\n\n                //cleanup unmanaged resources, you may chain it to a private method in this class\n\n                this.disposed = true;\n            }\n        }\n    }  \n}\n\nand now a derived class:\n\n\n\n\n    public class MyDerivedHelper : MyHelper\n    {\n        private bool disposed;\n\n        protected override void Dispose(bool isDisposing)\n        {\n            if (!this.disposed)\n            {\n                if (isDisposing)\n                {\n                    //cleanup managed resources here, you may also chain it to a private method in this class\n                }\n\n                //cleanup unmanaged resources, you may chain it to a private method in this class\n\n                this.disposed = true;\n            }\n\n            //call the base class's dispose\n            base.Dispose(isDisposing);\n        }\n    }\n\n\n- Hmm... This sort of implies that you never inherit a Disposable class. If you call Dispose on the derived class you would have to override the Dispose method itself repeating the whole pattern.  ->>>>> see me previous comment, you can call those methods within the virtual or overriden Dispose method.\n- A finalizer should ONLY be used for releasing unmanaged resources (as you say yourself), and that is exactly what I do. Look at the code again :O) Not only that. A finalizer should ALWAYS be used for releasing unmanaged resources. because otherwise you have no guarantee they will be released. Of course you have a point that if there are no unmanaged resources there are no reason to provide a finalizer. But then again, you will not be able to convince me that a finalizer that does nothing is expensive :O) And furthermore this pattern is just a best practice attempt, and consequently I have to provide the finalizer.   ->>>>> If an object uses a finalizer and it is being collected by the GC when it is out of scope, the GC places it on a finalizer queue. In the next GC cycle all finalizers on the queue are run (on a single thread in the current implementation) and the memory from the finalized objects reclaimed. It's fairly obvious from this why you don't want to do clean up in a finalizer: it takes two GC cycles to collect the object instead of one and there is a single thread where all finalizers are run while every other thread is suspended, so it's going to hurt performance.\n\n- I guess you are right. But again this is a best practice attempt. This attribute means exactly the same as lock(this), but is better because it locks the entire method which lock(this) only does if you do it right ;O). Just consider two different threads trying to Dispose the same object, without the lock they could both be trying to free the same unmanaged ressources which could potentially be dangerous. BTW: The lock statement I also got from Juval's book. I just brought it into the present with the MethodImpl attribute, which Juval often prefers too. ->>>>> it may be a best practice when multi threading is used in a project, but that is not always the case...\n\n- Well it is just coding style, but I strongly disagree :O) I code by IDesigns coding standard which uses m_ and which is written by - guess who - Juval Lowy :O) And why is it wrong to use camelCasing ? Because it forces you to use the this keyword, which should only be used during development IMHO (and of course for extension methods and constructors. Microsoft is split on this matter. Their generated code often looks like what you describe, and at other times uses an underscore as prefix. The first one is wrong (IMHO), the second is a matter of coding style. ->>>>> well, I think this could lead to a religious discussion, but I only want to say this: MS .NET library had different teams, where the guidelines stated in the Framework Design Guidelines(FDG) book was not landed on every team, also enforcing the rules was not always the case, and there was a time-delivering pressure at the different teams. That leads to inconsistent usage of private members (and variables). Nowdays MS is enforcing the guidelines from the FDG strongly, but I think \"old\" code could still be in its old inconsistent state when analyzing it with Reflector for example. But... when using the MS guidelines stated in FDG, you adapt a style that is becoming more and more common practice and easier for teams to add new teammembers that are familiar with these guidelines.\n\n\n\nPatrick","date":"2009-06-24T08:46:14.8972968+02:00"}


